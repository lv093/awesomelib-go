## 排序算法

### 插入排序
- 描述

    插入排序通过循环方式，将每一个元素放置到前面的有序数组中，放置过程中需要移动目标和当前位置的所有元素。

### 快速排序
- 描述

    快速排序采用分治算法：分解、解决、合并。
    
    **分解：**  
        
        根据某个目标值对数组分割成两个子数组A[p..q-1],A[q+1..r]，使得左边数组的每个元素都小于A[q],右边数组的每个元素都大于A[q].
    **解决：**  通过递归调用快速排序，分别对两个子数组进行排序
    
    **合并：**  最终组合各排序结果。
- 伪代码

<pre><code>
QuickSort(A, p, r)
    if(p < r) {
        q = Partition(A, p, r)
        QuickSort(A, p, q - 1)
        QuickSort(A, q + 1, r)
    }

    
    
Partition(A, p, r)
    pivot = A[r]
    i, j = p - 1, p
    for j = p => r {
        if(A[j] <= pivot) {
            i++
            swap(A[i], A[j])
        }
    }
    swap(A[i + 1], A[r])
    return i + 1
</code></pre>

### 堆排序

- 描述

    堆排序就是利用构建堆和输出堆顶元素的过程，不断对堆进行调整以保证当前结点及其孩子结点满足堆特性，从而达到对初始数组元素进行排序的目的。
    大顶堆通常对应升序序列，小顶堆通常对应降序排列。
    
- 基本过程

    首先对整个数组构建成为大顶堆。这样就满足大顶堆的性质：位于根节点的元素一定是当前序列的最大值。
    
    然后取出该堆的堆顶元素，与数组末尾元素进行交换。
    
    对交换后的n-1个元素组成的数组，进行调整，使其满足大顶堆的性质。
    
    重复上述两个步骤，直至堆中只有1个元素为止。

## 字符串匹配算法

- 问题描述

<pre><code>
    - 文本Text是一个长度为n的数组T[1...n]
    - 模式Pattern是一个长度为m，且m<=n的数组P[1...m]
    - T和P都属于有限字母表
    - 如果0<=s<=n-m，且T[s+1...s+m] = P[1...m]。则说模式P在文本T中出现，且位移为s，且称s是一个有效位移（valid shift）。
</code></pre>

![字符串匹配算法](./resources/images/string_match.png)
    
    如图所示，目标是找出所有在文本 T = abcabaabcabac 中模式 P = abaa 的所有出现。该模式在此文本中仅出现一次，即在位移 s = 3 处，位移 s = 3 是有效位移。

- 算法示例
    - Naive String Matching
    - KMP
    - BM
    - Horspool
    - Sunday
    - KR
    - AC算法